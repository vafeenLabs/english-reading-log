В предыдущей статье «Основы компоновки MAD Skills» вы научились думать в Compose — вы описываете свой пользовательский интерфейс в Kotlin как функции. XML больше не нужен! В этой статье мы углубимся в эти функции и в то, как с их помощью можно создать пользовательский интерфейс.

> Напоминаем, что мы ответим на ваши вопросы по основам компоновки в ходе нашей прямой трансляции вопросов и ответов 13 октября. Обязательно оставьте комментарий здесь, на YouTube или с помощью хэштега #MADCompose в Твиттере.

Чтобы понять, как работают эти функции, давайте посмотрим, как мы можем создать экран вопросов с одним выбором для Jetsurvey (один из наших примеров Compose).

Посмотреть сопутствующее видео к этой статье можно здесь:

# Простая составная функция

Один ответ в опросе можно записать в Compose как функцию, содержащую строку с изображением, текстом и радиокнопку.

Чтобы создать компонент пользовательского интерфейса в Compose, мы должны пометить функцию аннотацией `**@Composable**` . Эта аннотация сообщает компилятору Compose, что эта функция предназначена для преобразования данных в пользовательский интерфейс, поэтому и ответ в пользовательский интерфейс.¹

Функции с этой аннотацией также называются **составными** **функциями** или для краткости составными. Эти функции являются строительными блоками пользовательского интерфейса в Compose. Добавить эту аннотацию можно быстро и легко, побуждая вас организовать свой пользовательский интерфейс в библиотеку элементов многократного использования.

Например, чтобы реализовать список возможных ответов для выбора, мы можем определить новую функцию под названием «SingleChoiceQuestion», которая принимает список ответов, а затем вызвать функцию «SurveyAnswer», которую мы только что определили.

`SingleChoiceQuestion` принимает параметры, которые позволяют настраивать его с помощью логики приложения. В этом случае он принимает список возможных ответов, чтобы отобразить эти параметры в пользовательском интерфейсе. Обратите внимание, что составной элемент ничего не возвращает (он возвращает Unit), а вместо этого **выдает пользовательский интерфейс**. В частности, он создает компонуемый макет «Столбец», который является частью набора инструментов Compose, который упорядочивает элементы по вертикали. Внутри столбца он выдает SurveyAnswer, который можно составить для каждого ответа.

Составные элементы **неизменяемы**. Вы не можете хранить ссылку на них — например, ссылку на один ответ — и позже обновлять их содержимое. Вам необходимо передать любую информацию в качестве параметров при ее вызове.

Обратите внимание: поскольку функция написана на Kotlin, мы можем использовать полный синтаксис Kotlin и поток управления для создания пользовательского интерфейса. Здесь мы используем forEach для перебора каждого ответа и вызываем SurveyAnswer для их отображения. Если мы хотим условно отобразить что-то еще, это так же просто, как использовать оператор if. Никаких View.visibility = View.GONE или View.INVISIBLE не требуется. При использовании декларативной инфраструктуры пользовательского интерфейса, такой как Compose, если вы хотите, чтобы ваш пользовательский интерфейс выглядел по-разному в зависимости от предоставленных входных данных, составной элемент должен описывать, как ваш пользовательский интерфейс должен выглядеть для каждого возможного значения входных данных. Используя условные операторы, подобные этому фрагменту, вы можете добиться этого.

Компонуемые объекты должны быть **быстрыми и не иметь побочных эффектов**. Он должен вести себя одинаково при многократном вызове с одним и тем же аргументом и не должен изменять свойства или глобальные переменные. Мы говорим, что функции с этим свойством являются _идемпотентными_. Это свойство необходимо для всех компонуемых объектов, чтобы пользовательский интерфейс мог корректно создаваться при повторном вызове функций с новыми значениями.

Обратите внимание, что параметры, предоставленные функциям **полностью** **контролируют пользовательский интерфейс**. Это то, что мы подразумеваем под преобразованием состояния в пользовательский интерфейс. Логика функции гарантирует, что пользовательский интерфейс никогда не выйдет из синхронизации. Если список ответов изменяется, то новый пользовательский интерфейс генерируется из нового списка ответов путем повторного выполнения этой функции и перерисовки пользовательского интерфейса при необходимости.

Этот процесс регенерации пользовательского интерфейса при изменении состояния называется **рекомпозицией**. Поскольку составные объекты неизменяемы, рекомпозиция — это механизм обновления пользовательского интерфейса с новым состоянием.

# Рекомпозиция и состояние компонуемых функций

Рекомпозиция происходит, когда компонуемый объект повторно вызывается с другими параметрами функции. Это происходит потому, что утверждается, что функция зависит от изменений.

Например, предположим, что составной элемент SurveyAnswer принимает параметр isSelected, который определяет, выбран ли ответ или нет. Изначально ответ не выбран:

В мире представлений взаимодействие путем нажатия на один из элементов пользовательского интерфейса ответа будет визуально переключать его, поскольку представления сохраняют свое собственное состояние. Однако в мире Compose, поскольку всем составным объектам SurveyAnswer присваивается **false** , все ответы останутся невыбранными, несмотря на взаимодействие с пользователем. Чтобы заставить их визуально реагировать на взаимодействие с пользователем, компоновку необходимо перекомпоновать, чтобы пользовательский интерфейс мог быть перегенерирован с новым состоянием.

Для этого необходимо ввести новую переменную, содержащую выбранный ответ. Кроме того, переменная должна быть `[MutableState]
— наблюдаемый тип, интегрированный в среду выполнения Compose. Любые изменения в состоянии автоматически планируют перекомпоновку для любых компонуемых объектов, которые его читают. 

Обратите внимание, что в приведенном выше фрагменте значение isSelected было обновлено для сравнения текущего ответа с selectedAnswer. Поскольку selectedAnswer имеет тип MutableState, нам нужно использовать свойство value, чтобы получить выбранный ответ. Когда это значение изменится, Compose автоматически повторно выполнит SurveyAnswer, чтобы выбранный ответ был выделен.

==Однако приведенный== выше фрагмент не совсем работает. Значение selectedAnswer необходимо запомнить при рекомпозиции, чтобы оно не перезаписывалось при повторном вызове SingleChoiceQuestion. Чтобы это исправить, вызов mutableStateOf должен выполняться внутри вызова запоминания. Это гарантирует, что значение запоминается, а не сбрасывается при перекомпоновке компонуемого объекта. Чтобы запомнить значения при изменении конфигурации, мы также можем использовать memberSaveable:

Приведенный выше фрагмент кода можно дополнительно усовершенствовать, используя синтаксис делегированных свойств Kotlin для переменной «selectedAnswer». При этом тип изменится с `MutableState<Answer?>` на простой `Answer?`. Этот синтаксис довольно удобен, поскольку мы можем работать напрямую со значением базового состояния — больше не нужно вызывать свойство value объекта MutableState:

Благодаря нашему новому состоянию мы можем передать лямбда-функцию для параметра onAnswerSelected, чтобы мы могли выполнять действие, когда пользователь делает выбор. В определении этой лямбды мы можем установить новое значение для `selectedAnswer`:

Если вы помните из предыдущей статьи, события — это механизм обновления состояния. Здесь событие onAnswerSelected будет вызываться, когда пользователь взаимодействует, нажимая на ответ.

Среда выполнения Compose автоматически отслеживает, где происходит чтение состояния, чтобы можно было интеллектуально перекомпоновать компонуемые объекты, зависящие от этого состояния. В результате **вам не нужно явно отслеживать состояние или вручную обновлять пользовательский интерфейс**.

# Поведение и свойства составных элементов

Существуют и другие поведенческие свойства составных функций, о которых вам также следует знать. Из-за такого поведения **важно, чтобы ваши составные функции не имели побочных эффектов и вели себя одинаково при многократном вызове с одним и тем же аргументом**.

Глядя на фрагмент ниже, вы можете предположить, что код выполняется последовательно. Но это не обязательно так. Compose может распознать, что некоторые элементы пользовательского интерфейса имеют более высокий приоритет, чем другие, и поэтому эти элементы могут быть нарисованы первыми. Скажем, например, у вас есть код, который рисует три экрана в макете вкладок. Вы можете предположить, что сначала выполняется StartScreen, однако эти выполнения могут происходить в любом порядке.

Composables могут работать параллельно, используя преимущества нескольких ядер, что повышает производительность рендеринга экрана. В приведенном ниже фрагменте кода код выполняется без побочных эффектов и преобразует список ввода в пользовательский интерфейс.

Однако если функция записывает данные в локальную переменную, как показано во фрагменте ниже, код больше не считается свободным от побочных эффектов. Выполнение чего-то похожего на приведенный ниже код может привести к странному поведению вашего пользовательского интерфейса.


Compose делает все возможное, чтобы перекомпоновать только те части пользовательского интерфейса, которые необходимо обновить. Если компонуемый объект не использует состояние, вызвавшее рекомпозицию, он будет пропущен. В фрагменте, если строка имени изменится, компонуемые элементы Header и Footer не будут выполняться повторно, поскольку это не зависит от этого состояния.


Рекомпозиция оптимистична — это означает, что Compose рассчитывает завершить рекомпозицию до того, как параметры снова изменятся. Если параметр изменится до завершения рекомпозиции, Compose может отменить рекомпозицию и перезапустить ее с новым параметром.

Наконец, составные функции могут выполняться часто. Это может быть тот случай, если ваша составная функция содержит анимацию, которую необходимо выполнять для каждого кадра. Вот почему важно убедиться, что ваши компонуемые функции работают быстро, чтобы избежать пропущенных кадров.

Если вам нужно выполнить длительную операцию, не делайте этого в составной функции. Вместо этого выполняйте ее вне потока пользовательского интерфейса и используйте результат только в составной функции.

# Краткое содержание

Мы многое рассмотрели! Обобщить:

- Вы можете создавать составные функции, используя аннотацию `@Composable` .
- Создавать составные элементы можно быстро и легко, что побуждает вас организовать свой пользовательский интерфейс в библиотеку компонентов многократного использования.
- Компонуемые объекты могут и должны принимать параметры для настройки своего поведения.
- **MutableState, Remember** и **rememberSaveable** можно использовать для хранения состояния компонента, а Compose автоматически отслеживает и перекомпоновывает изменения.
- Композитные материалы не должны иметь побочных эффектов.

Мы также узнали о некоторых интересных свойствах составных объектов. Компонуемые предметы могут:

- Выполнять в любом порядке
- Работать параллельно
- Быть пропущенным
- Часто исполняемыми

Набор инструментов Compose предоставляет множество базовых и мощных компонуемых компонентов, которые помогут вам создавать красивые приложения.